---
description: Правила создания сервисов в бизнес-модулях
globs:
  - "app/BusinessModules/**/Services/*.php"
alwaysApply: true
---

# Создание сервисов в модулях

## Принципы организации сервисов

Сервисы содержат **бизнес-логику** модуля и должны быть:
- ✅ Независимыми от HTTP слоя (контроллеров)
- ✅ Переиспользуемыми (из контроллеров, команд, jobs)
- ✅ Тестируемыми (внедрение зависимостей)
- ✅ Однозначными по ответственности (Single Responsibility)

## Структура директории Services

```
app/BusinessModules/{Category}/{Module}/Services/
├── {Module}Service.php              # Главный сервис модуля
├── {Entity}Manager.php               # CRUD операции над сущностью
├── {Feature}Service.php              # Специфичная бизнес-логика
├── {Integration}Client.php           # Внешние интеграции
├── Helpers/
│   └── {Helper}Service.php          # Вспомогательные сервисы
└── Contracts/
    └── {Service}Interface.php       # Интерфейсы сервисов
```

## Типы сервисов

### 1. Основной сервис модуля ({Module}Service)

Центральная точка входа для работы с модулем. Координирует другие сервисы.

```php
<?php

namespace App\BusinessModules\Features\MyModule\Services;

use App\BusinessModules\Features\MyModule\Models\MyEntity;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\DB;

class MyModuleService
{
    private const CACHE_TTL = 3600; // 1 час

    public function __construct(
        private readonly MyEntityManager $entityManager,
        private readonly ValidationService $validator,
        private readonly CacheService $cache,
    ) {}

    /**
     * Получить данные для дашборда
     */
    public function getDashboardData(int $organizationId): array
    {
        return Cache::remember(
            "my_module_dashboard_{$organizationId}",
            self::CACHE_TTL,
            fn() => $this->buildDashboardData($organizationId)
        );
    }

    /**
     * Создать новую сущность
     */
    public function create(int $organizationId, array $data): MyEntity
    {
        // 1. Валидация бизнес-правил
        $this->validator->validateCreation($data);

        // 2. Проверка лимитов
        $this->checkLimits($organizationId);

        // 3. Создание через менеджер
        $entity = DB::transaction(function () use ($organizationId, $data) {
            return $this->entityManager->create($organizationId, $data);
        });

        // 4. Инвалидация кеша
        $this->cache->invalidateForOrganization($organizationId);

        // 5. Логирование
        \Log::info('my_module.entity.created', [
            'organization_id' => $organizationId,
            'entity_id' => $entity->id,
        ]);

        return $entity;
    }

    /**
     * Обновить сущность
     */
    public function update(MyEntity $entity, array $data): MyEntity
    {
        $this->validator->validateUpdate($entity, $data);

        $updated = DB::transaction(function () use ($entity, $data) {
            return $this->entityManager->update($entity, $data);
        });

        $this->cache->invalidateForOrganization($entity->organization_id);

        return $updated;
    }

    /**
     * Удалить сущность
     */
    public function delete(MyEntity $entity): bool
    {
        $organizationId = $entity->organization_id;

        $deleted = DB::transaction(function () use ($entity) {
            return $this->entityManager->delete($entity);
        });

        if ($deleted) {
            $this->cache->invalidateForOrganization($organizationId);
        }

        return $deleted;
    }

    /**
     * Проверка лимитов модуля
     */
    private function checkLimits(int $organizationId): void
    {
        $settings = $this->getModuleSettings($organizationId);
        $currentCount = MyEntity::where('organization_id', $organizationId)->count();

        if ($currentCount >= $settings['max_items']) {
            throw new \DomainException("Достигнут лимит: {$settings['max_items']} сущностей");
        }
    }

    /**
     * Получить настройки модуля
     */
    private function getModuleSettings(int $organizationId): array
    {
        $module = app(\App\BusinessModules\Features\MyModule\MyModuleModule::class);
        return $module->getSettings($organizationId);
    }

    /**
     * Построить данные дашборда (приватный метод)
     */
    private function buildDashboardData(int $organizationId): array
    {
        return [
            'total' => $this->entityManager->getTotalCount($organizationId),
            'active' => $this->entityManager->getActiveCount($organizationId),
            'recent' => $this->entityManager->getRecent($organizationId, 10),
            'stats' => $this->entityManager->getStatistics($organizationId),
        ];
    }
}
```

### 2. Менеджер сущности ({Entity}Manager)

Отвечает за CRUD операции и запросы к БД для конкретной сущности.

```php
<?php

namespace App\BusinessModules\Features\MyModule\Services;

use App\BusinessModules\Features\MyModule\Models\MyEntity;
use Illuminate\Database\Eloquent\Collection;

class MyEntityManager
{
    /**
     * Создать сущность
     */
    public function create(int $organizationId, array $data): MyEntity
    {
        return MyEntity::create([
            'organization_id' => $organizationId,
            ...$data,
        ]);
    }

    /**
     * Обновить сущность
     */
    public function update(MyEntity $entity, array $data): MyEntity
    {
        $entity->update($data);
        return $entity->fresh();
    }

    /**
     * Удалить сущность
     */
    public function delete(MyEntity $entity): bool
    {
        return $entity->delete();
    }

    /**
     * Получить по ID с проверкой организации
     */
    public function findForOrganization(int $id, int $organizationId): ?MyEntity
    {
        return MyEntity::where('id', $id)
            ->where('organization_id', $organizationId)
            ->first();
    }

    /**
     * Получить все для организации
     */
    public function getAllForOrganization(int $organizationId): Collection
    {
        return MyEntity::where('organization_id', $organizationId)
            ->orderBy('created_at', 'desc')
            ->get();
    }

    /**
     * Получить с пагинацией
     */
    public function paginateForOrganization(int $organizationId, int $perPage = 15)
    {
        return MyEntity::where('organization_id', $organizationId)
            ->orderBy('created_at', 'desc')
            ->paginate($perPage);
    }

    /**
     * Получить недавние
     */
    public function getRecent(int $organizationId, int $limit = 10): Collection
    {
        return MyEntity::where('organization_id', $organizationId)
            ->orderBy('created_at', 'desc')
            ->limit($limit)
            ->get();
    }

    /**
     * Статистика
     */
    public function getStatistics(int $organizationId): array
    {
        return [
            'total' => $this->getTotalCount($organizationId),
            'active' => $this->getActiveCount($organizationId),
            'inactive' => $this->getInactiveCount($organizationId),
        ];
    }

    public function getTotalCount(int $organizationId): int
    {
        return MyEntity::where('organization_id', $organizationId)->count();
    }

    public function getActiveCount(int $organizationId): int
    {
        return MyEntity::where('organization_id', $organizationId)
            ->where('is_active', true)
            ->count();
    }

    public function getInactiveCount(int $organizationId): int
    {
        return MyEntity::where('organization_id', $organizationId)
            ->where('is_active', false)
            ->count();
    }
}
```

### 3. Сервис валидации

```php
<?php

namespace App\BusinessModules\Features\MyModule\Services;

use App\BusinessModules\Features\MyModule\Models\MyEntity;

class ValidationService
{
    /**
     * Валидация при создании
     */
    public function validateCreation(array $data): void
    {
        // Бизнес-правила валидации
        if (empty($data['name'])) {
            throw new \InvalidArgumentException('Имя обязательно');
        }

        if (isset($data['amount']) && $data['amount'] < 0) {
            throw new \InvalidArgumentException('Сумма не может быть отрицательной');
        }

        // Проверка уникальности
        $exists = MyEntity::where('name', $data['name'])
            ->where('organization_id', $data['organization_id'] ?? null)
            ->exists();

        if ($exists) {
            throw new \DomainException('Сущность с таким именем уже существует');
        }
    }

    /**
     * Валидация при обновлении
     */
    public function validateUpdate(MyEntity $entity, array $data): void
    {
        // Проверка состояния
        if ($entity->is_locked) {
            throw new \DomainException('Сущность заблокирована для изменений');
        }

        // Бизнес-правила
        if (isset($data['status']) && !$this->canChangeStatus($entity, $data['status'])) {
            throw new \DomainException('Недопустимое изменение статуса');
        }
    }

    /**
     * Проверка возможности изменения статуса
     */
    private function canChangeStatus(MyEntity $entity, string $newStatus): bool
    {
        // Бизнес-логика переходов статусов
        $allowedTransitions = [
            'draft' => ['active', 'cancelled'],
            'active' => ['completed', 'cancelled'],
            'completed' => [],
            'cancelled' => [],
        ];

        return in_array($newStatus, $allowedTransitions[$entity->status] ?? []);
    }
}
```

### 4. Сервис кеширования

```php
<?php

namespace App\BusinessModules\Features\MyModule\Services;

use Illuminate\Support\Facades\Cache;

class CacheService
{
    private const TTL = 3600; // 1 час
    private const TAG_PREFIX = 'my_module';

    /**
     * Инвалидация кеша для организации
     */
    public function invalidateForOrganization(int $organizationId): void
    {
        $tags = [
            self::TAG_PREFIX,
            self::TAG_PREFIX . "_org_{$organizationId}",
        ];

        if (config('cache.default') === 'redis') {
            Cache::tags($tags)->flush();
        } else {
            // Fallback для драйверов без поддержки тегов
            $this->flushKeysByPattern($organizationId);
        }
    }

    /**
     * Инвалидация конкретной сущности
     */
    public function invalidateEntity(int $entityId, int $organizationId): void
    {
        Cache::forget("my_module_entity_{$entityId}");
        $this->invalidateForOrganization($organizationId);
    }

    /**
     * Получить или создать кеш
     */
    public function remember(string $key, callable $callback, ?int $ttl = null)
    {
        return Cache::remember($key, $ttl ?? self::TTL, $callback);
    }

    /**
     * Fallback для удаления ключей по паттерну
     */
    private function flushKeysByPattern(int $organizationId): void
    {
        $patterns = [
            "my_module_dashboard_{$organizationId}",
            "my_module_stats_{$organizationId}",
            "my_module_list_{$organizationId}",
        ];

        foreach ($patterns as $pattern) {
            Cache::forget($pattern);
        }
    }
}
```

### 5. Интеграционный клиент

```php
<?php

namespace App\BusinessModules\Features\MyModule\Services;

use Illuminate\Support\Facades\Http;

class ExternalApiClient
{
    private string $baseUrl;
    private string $apiKey;

    public function __construct()
    {
        $this->baseUrl = config('my-module.api_url');
        $this->apiKey = config('my-module.api_key');
    }

    /**
     * Синхронизация данных с внешним API
     */
    public function syncData(int $organizationId): array
    {
        try {
            $response = Http::withHeaders([
                'Authorization' => "Bearer {$this->apiKey}",
                'Accept' => 'application/json',
            ])
            ->timeout(30)
            ->get("{$this->baseUrl}/organizations/{$organizationId}/data");

            if ($response->failed()) {
                throw new \RuntimeException("API error: {$response->status()}");
            }

            return $response->json();
        } catch (\Exception $e) {
            \Log::error('my_module.api.sync_failed', [
                'organization_id' => $organizationId,
                'error' => $e->getMessage(),
            ]);

            throw $e;
        }
    }
}
```

## Регистрация сервисов в ServiceProvider

```php
protected function registerServices(): void
{
    // Singleton - один экземпляр на весь запрос
    $this->app->singleton(MyModuleService::class);
    $this->app->singleton(CacheService::class);
    
    // Bind - новый экземпляр каждый раз
    $this->app->bind(MyEntityManager::class);
    $this->app->bind(ValidationService::class);
    
    // С параметрами в конструкторе
    $this->app->singleton(ExternalApiClient::class, function ($app) {
        return new ExternalApiClient(
            config('my-module.api_url'),
            config('my-module.api_key')
        );
    });
}
```

## Использование сервисов

### В контроллерах

```php
class MyController extends Controller
{
    public function __construct(
        private readonly MyModuleService $service
    ) {}

    public function index(Request $request)
    {
        $orgId = $request->attributes->get('current_organization_id');
        $data = $this->service->getDashboardData($orgId);
        
        return response()->json(['success' => true, 'data' => $data]);
    }

    public function store(Request $request)
    {
        $orgId = $request->attributes->get('current_organization_id');
        $entity = $this->service->create($orgId, $request->validated());
        
        return response()->json(['success' => true, 'data' => $entity], 201);
    }
}
```

### В командах Artisan

```php
class SyncDataCommand extends Command
{
    public function __construct(
        private readonly MyModuleService $service
    ) {
        parent::__construct();
    }

    public function handle()
    {
        $organizations = Organization::where('is_active', true)->get();
        
        foreach ($organizations as $org) {
            try {
                $this->service->syncData($org->id);
                $this->info("Synced org {$org->id}");
            } catch (\Exception $e) {
                $this->error("Failed org {$org->id}: {$e->getMessage()}");
            }
        }
    }
}
```

### В Jobs

```php
class ProcessDataJob implements ShouldQueue
{
    public function __construct(
        private int $organizationId,
        private array $data
    ) {}

    public function handle(MyModuleService $service)
    {
        $service->processData($this->organizationId, $this->data);
    }
}
```

## Лучшие практики

1. ✅ **Dependency Injection**: внедряйте зависимости через конструктор
2. ✅ **Type Hints**: всегда указывайте типы параметров и возвращаемых значений
3. ✅ **Single Responsibility**: один сервис = одна ответственность
4. ✅ **Транзакции**: оборачивайте критичные операции в DB::transaction()
5. ✅ **Кеширование**: кешируйте тяжелые операции
6. ✅ **Логирование**: логируйте важные события и ошибки
7. ✅ **Валидация**: валидируйте на уровне сервисов, не только в Request
8. ✅ **Тестируемость**: пишите юнит-тесты для сервисов
9. ✅ **Документация**: добавляйте PHPDoc комментарии
10. ✅ **Обработка ошибок**: используйте try-catch и выбрасывайте понятные исключения
